// Generated by CoffeeScript 1.7.1
(function() {
  var Game, Sprite, Unit, game,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Sprite = (function() {
    function Sprite(x, y, width, height, image) {
      this.x = x;
      this.y = y;
      this.frame = 0;
      this.width = width;
      this.height = height;
      this.image = image;
      this.animFrames = [];
      this.animDelay = 1000;
      this.animElapsed = 0;
    }

    Sprite.prototype.render = function(ctx) {
      return ctx.drawImage(this.image, (this.frame % 8) * this.width, Math.floor(this.frame / 8) * this.height, this.width, this.height, this.x, this.y, this.width, this.height);
    };

    Sprite.prototype.update = function(dt) {
      var i;
      this.animElapsed += dt;
      if (this.animElapsed > this.animDelay) {
        i = this.animFrames.indexOf(this.frame);
        i += 1;
        if (i >= this.animFrames.length) {
          i = 0;
        }
        this.frame = this.animFrames[i];
        return this.animElapsed = 0;
      }
    };

    Sprite.prototype.animate = function(animFrames, animDelay) {
      this.animFrames = animFrames;
      return this.animDelay = animDelay;
    };

    return Sprite;

  })();

  Unit = (function() {
    function Unit() {
      this.facing = 'down';
      this.walkDelay = 0.1;
      this.speed = 120;
      this.health = 10;
      this.force = null;
      this.grace = null;
      this.hopeReward = 10;
    }

    Unit.prototype.face = function(dir) {
      if (this.facing === dir) {
        return;
      }
      this.facing = dir;
      if (dir === 'left') {
        return this.sprite.frame = 11;
      } else if (dir === 'right') {
        return this.sprite.frame = 15;
      } else if (dir === 'up') {
        return this.sprite.frame = 4;
      } else if (dir === 'down') {
        return this.sprite.frame = 0;
      }
    };

    Unit.prototype.walk = function(dir) {
      this.walking = true;
      if (this.facing === 'left') {
        return this.sprite.animate([8, 9], this.walkDelay);
      } else if (this.facing === 'right') {
        return this.sprite.animate([12, 13], this.walkDelay);
      } else if (this.facing === 'up') {
        return this.sprite.animate([5, 7], this.walkDelay);
      } else if (this.facing === 'down') {
        return this.sprite.animate([1, 3], this.walkDelay);
      }
    };

    Unit.prototype.stopWalking = function() {
      this.walking = false;
      return this.sprite.animate([]);
    };

    Unit.prototype.applyForce = function(value, duration) {
      return this.force = {
        value: value,
        duration: duration,
        elapsed: 0
      };
    };

    Unit.prototype.applyGrace = function(duration) {
      return this.grace = {
        duration: duration,
        elapsed: 0,
        flashPeriod: 0.05,
        flashElapsed: 0,
        flash: true
      };
    };

    Unit.prototype.collides = function(unit) {
      return Geometry.rectHitsRect(this.sprite.x, this.sprite.y, this.sprite.width, this.sprite.height, unit.sprite.x, unit.sprite.y, unit.sprite.width, unit.sprite.height);
    };

    Unit.prototype.update = function(dt) {
      var cx, cy, dir, inc, p, tx, ty;
      if (this.walking) {
        inc = Math.ceil(this.speed * dt);
        if (this.facing === 'left') {
          this.sprite.x -= inc;
        } else if (this.facing === 'right') {
          this.sprite.x += inc;
        } else if (this.facing === 'up') {
          this.sprite.y -= inc;
        } else if (this.facing === 'down') {
          this.sprite.y += inc;
        }
      }
      if (this === game.bars) {
        if (this.sprite.x < 0) {
          this.sprite.x = 0;
        }
        if (this.sprite.x + this.sprite.width > atom.canvas.width) {
          this.sprite.x = atom.canvas.width - this.sprite.width;
        }
        if (this.sprite.y < 0) {
          this.sprite.y = 0;
        }
        if (this.sprite.y + this.sprite.width > atom.canvas.height) {
          this.sprite.y = atom.canvas.height - this.sprite.height;
        }
      } else if (this.sprite.x < -this.sprite.width || this.sprite.x > atom.canvas.width || this.sprite.y < -this.sprite.height || this.sprite.y > atom.canvas.height) {
        return this.die();
      }
      if (this.grace) {
        this.grace.elapsed += dt;
        this.grace.flashElapsed += dt;
        if (this.grace.elapsed > this.grace.duration) {
          this.grace = null;
        } else if (this.grace.flashElapsed > this.grace.flashPeriod) {
          this.grace.flashElapsed = 0;
          this.grace.flash = !this.grace.flash;
        }
      }
      if (this.force) {
        this.sprite.x += this.force.value.x;
        this.sprite.y += this.force.value.y;
        this.force.elapsed += dt;
        if (this.force.elapsed > this.force.duration) {
          this.force = null;
        }
      }
      if (this !== game.bars) {
        cx = this.sprite.x;
        cy = this.sprite.y;
        tx = game.bars.sprite.x;
        ty = game.bars.sprite.y;
        dir = Geometry.facingFromLine(cx, cy, tx, ty);
        this.face(dir);
        this.walk();
        if (this.collides(game.bars) && !game.bars.grace) {
          p = new Point(tx - cx, ty - cy).normalize().scale(2);
          game.bars.applyForce(p, 0.5);
          game.bars.applyGrace(0.2);
          game.hope -= 5 * Math.pow(2, game.level);
          if (game.hope <= 0) {
            if (game.level > 1) {
              game.levelDown();
            } else {
              game.over();
            }
          }
        }
      }
      return this.sprite.update(dt);
    };

    Unit.prototype.die = function() {
      this.dead = true;
      if (this.force) {
        game.hope += this.hopeReward;
        if (game.hope >= game.nextHope) {
          return game.levelUp();
        }
      }
    };

    Unit.prototype.render = function(ctx) {
      ctx.save();
      if (this.grace && this.grace.flash) {
        ctx.globalAlpha = 0.1;
      }
      this.sprite.render(ctx);
      return ctx.restore();
    };

    return Unit;

  })();

  Game = (function(_super) {
    var img;

    __extends(Game, _super);

    function Game() {
      var i, img, _i;
      Game.__super__.constructor.apply(this, arguments);
      atom.input.bind(atom.key.A, 'left');
      atom.input.bind(atom.key.D, 'right');
      atom.input.bind(atom.key.W, 'up');
      atom.input.bind(atom.key.S, 'down');
      atom.input.bind(atom.key.V, 'debug');
      atom.input.bind(atom.button.LEFT, 'click');
      atom.context.lineCap = 'round';
      this.bars = new Unit();
      img = new Image();
      img.src = 'barsamin.png';
      this.bars.sprite = new Sprite(atom.canvas.width / 2, atom.canvas.height / 2, 16, 16, img);
      this.level = 0;
      this.levelUp();
      this.enemies = [];
      for (i = _i = 0; _i <= 9; i = ++_i) {
        this.spawnEnemy();
      }
    }

    img = new Image();

    img.src = 'katarosi.png';

    Game.prototype.spawnEnemy = function() {
      var enemy, height, width, x, y;
      enemy = new Unit();
      enemy.speed = 10 * Math.pow(2, this.level) / 2;
      width = 16;
      height = 16;
      if (Math.random() > 0.5) {
        x = _.sample([0, atom.canvas.width - width]);
        y = Math.floor(Math.random() * atom.canvas.height);
      } else {
        x = Math.floor(Math.random() * atom.canvas.height);
        y = _.sample([0, atom.canvas.height - height]);
      }
      enemy.sprite = new Sprite(x, y, width, height, img);
      return this.enemies.push(enemy);
    };

    Game.prototype.setLevel = function(level) {
      this.level = level;
      this.nextHope = Math.pow(2, this.level) * 100;
      this.arcRange = 20 * Math.pow(2, this.level);
      this.arcForce = 1 + Math.pow(2, this.level) * 2;
      return this.arcDamage = 1 + this.level;
    };

    Game.prototype.levelUp = function() {
      this.setLevel(this.level + 1);
      this.hope = 40;
      if (this.level > 1) {
        this.levelSpecial = {
          duration: 1,
          elapsed: 0
        };
        return Lightning.start();
      }
    };

    Game.prototype.levelDown = function() {
      this.setLevel(this.level - 1);
      return this.hope = Math.floor(this.nextHope * 0.9);
    };

    Game.prototype.update = function(dt) {
      var cx, cy, dir, enemy, mx, my, p, _i, _j, _len, _len1, _ref, _ref1;
      if (this.lost) {
        return;
      }
      if (this.levelSpecial) {
        this.levelSpecial.elapsed += dt;
        if (this.levelSpecial.elapsed > this.levelSpecial.duration) {
          this.levelSpecial = null;
          this.enemies = [];
          if (!atom.input.down('click')) {
            Lightning.stop();
          }
        }
        return;
      }
      this.bars.update(dt);
      _ref = this.enemies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        enemy = _ref[_i];
        enemy.update(dt);
      }
      if (atom.input.pressed('click')) {
        Lightning.start();
      }
      if (atom.input.released('click')) {
        Lightning.stop();
      }
      if (atom.input.down('click')) {
        cx = this.bars.sprite.x + this.bars.sprite.width / 2;
        cy = this.bars.sprite.y + this.bars.sprite.height / 2;
        mx = atom.input.mouse.x * (atom.canvas.width / window.innerWidth);
        my = atom.input.mouse.y * (atom.canvas.height / window.innerHeight);
        p = new Point(mx - cx, my - cy);
        if (p.length() > this.arcRange) {
          p = p.normalize(this.arcRange);
        }
        dir = Geometry.facingFromLine(cx, cy, mx, my);
        this.bars.face(dir);
        switch (dir) {
          case 'right':
            cx += 3;
            cy += 2;
            break;
          case 'left':
            cx -= 1;
            cy += 1;
            break;
          case 'down':
            cx += 1;
            cy += 4;
            break;
          case 'up':
            cx -= 4;
            cy += 2;
        }
        Lightning.dragPoints[0].x = cx;
        Lightning.dragPoints[0].y = cy;
        Lightning.dragPoints[1].x = cx + p.x;
        Lightning.dragPoints[1].y = cy + p.y;
        _ref1 = this.enemies;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          enemy = _ref1[_j];
          if (Geometry.lineHitsRect(cx, cy, cx + p.x, cy + p.y, enemy.sprite.x, enemy.sprite.y, enemy.sprite.width, enemy.sprite.height)) {
            p = new Point(mx - cx, my - cy).normalize().scale(this.arcForce);
            enemy.applyForce(p, 0.5);
            enemy.applyGrace(0.5);
            enemy.health -= this.arcDamage;
            if (enemy.health <= 0) {
              enemy.die();
            }
          }
        }
      }
      this.enemies = _.reject(this.enemies, function(enemy) {
        return enemy.dead;
      });
      if (atom.input.down('left')) {
        this.bars.face('left');
        this.bars.walk();
      } else if (atom.input.down('right')) {
        this.bars.face('right');
        this.bars.walk();
      } else if (atom.input.down('up')) {
        this.bars.face('up');
        this.bars.walk();
      } else if (atom.input.down('down')) {
        this.bars.face('down');
        this.bars.walk();
      } else {
        this.bars.stopWalking();
      }
      Lightning.update();
      if (Math.random() > 1 - (Math.pow(2, this.level) / 100)) {
        return this.spawnEnemy();
      }
    };

    Game.prototype.draw = function(dt) {
      var enemy, _i, _len, _ref;
      if (this.lost) {
        return;
      }
      if (!this.levelSpecial) {
        atom.context.globalCompositeOperation = 'source-over';
      }
      atom.context.fillStyle = 'rgba(10, 25, 30, 1.0)';
      atom.context.fillRect(0, 0, atom.width, atom.height);
      this.bars.render(atom.context);
      _ref = this.enemies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        enemy = _ref[_i];
        enemy.render(atom.context);
      }
      Lightning.draw();
      atom.context.fillStyle = "white";
      return atom.context.fillText("Hope: " + this.hope + "/" + this.nextHope + " [Level " + this.level + "]", 10, 10);
    };

    Game.prototype.over = function() {
      this.draw();
      this.stop();
      this.lost = true;
      return $('#gameover').modal();
    };

    return Game;

  })(atom.Game);

  game = new Game;

  $('#gameover').on('hidden.bs.modal', function() {
    return window.location.reload();
  });

  $('#intro').modal();

  $('#intro').on('hidden.bs.modal', function() {
    var canvas;
    canvas = document.getElementsByTagName('canvas')[0];
    canvas.style.display = 'block';
    Lightning.configure();
    window.onblur = function() {
      return game.stop();
    };
    window.onfocus = function() {
      return game.run();
    };
    return game.run();
  });

}).call(this);
